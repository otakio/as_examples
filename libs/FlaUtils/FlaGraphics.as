package  FlaUtils{	import flash.display.Sprite;	import flash.geom.ColorTransform;	import flash.geom.Transform;	import flash.display.Shape;		public class FlaGraphics {				private static var _lineWidth:uint = 0;		private static var _r:uint = 0;	//red. 0 to 255		private static var _g:uint = 0;	//green. 0 to 255		private static var _b:uint = 0;	//blue. 0 to 255		private static var _a:uint = 255;	//alpha. 0 to 255		private static var _color32:int = 0xffffffff;		private static var _color24:int = 0xffffff;		public static function setColor(r:int = 0, g:int = 0, b:int = 0, a:int = 255):void{			_r = r;			_g = g;			_b = b;			_a = a;			_color24 = _r << 16 | _g << 8 | _b;			_color32 = _a << 24 | _r << 16 | _g << 8 | _b;		}		public static function setHSBColor(hue:Number = 0, //0〜360										   saturation:Number = 0,	//0〜1.0 										   brightness:Number = 0	//0〜1.0										   ):void{			var r:Number = 0;			var g:Number = 0;			var b:Number = 0;			if(brightness == 0){				r = g = b = brightness;			}else{				if(saturation == 0){					r = g = b = saturation;				}else{					var h:Number = Math.floor(hue / 60) % 6;					var f:Number = hue / 60 - h;					var p:Number = brightness * (1.0 - saturation);					var q:Number = brightness * (1.0 - f * saturation);					var t:Number = brightness * (1.0 - (1.0 - f) * saturation);					switch(h){						case 0:							r = brightness;							g = t;							b = p;							break;						case 1:							r = q;							g = brightness;							b = p;							break;						case 2:							r = p;							g = brightness;							b = t;							break;						case 3:							r = p;							g = q;							b = brightness;							break;						case 4:							r = t;							g = p;							b = brightness;							break;						case 5:							r = brightness;							g = p;							b = q;							break;					}				}			}			setColor((int)(r*255.0), (int)(g*255.0), (int)(b*255.0));		}		public static function setLineWidth(w:int = 0):void{			_lineWidth = w;		}		public static function drawLine(target:Sprite, x1:int, y1:int, x2:int, y2:int):void{			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.moveTo(x1, y1);			target.graphics.lineTo(x2, y2);		}		public static function drawSprineCurve(target:Sprite, x1:int, y1:int, x2:int, y2:int, x3:int, y3:int){			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.moveTo(x1, y1); 			target.graphics.curveTo(x2, y2, x3, y3);      		}		public static function drawBezierCurve(target:Sprite, x1:int, y1:int, x2:int, y2:int, x3:int, y3:int, x4:int, y4:int){			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.moveTo(x1, y1);			 			// store values where to lineTo			var posx:Number;			var posy:Number;			 			//loop through 100 steps of the curve			for (var u:Number = 0; u <= 1; u += 1/100) {			 				posx = Math.pow(u,3)*(x4+3*(x2-x3)-x1)				+3*Math.pow(u,2)*(x1-2*x2+x3)				+3*u*(x2-x1)+x1;				 				posy = Math.pow(u,3)*(y4+3*(y2-y3)-y1)				+3*Math.pow(u,2)*(y1-2*y2+y3)				+3*u*(y2-y1)+y1;				 				target.graphics.lineTo(posx,posy);			 			}			 			//Let the curve end on the second anchorPoint			 			target.graphics.lineTo(x4,y4);		}		public static function drawCurves(target:Sprite, pts: Array):void{			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.moveTo(pts[0].x, pts[0].y);  			for(var i:uint = 1; i < pts.length-1; i++){			  target.graphics.curveTo(pts[i].x, pts[i].y, (pts[i].x + pts[i+1].x)/2, (pts[i].y+pts[i+1].y)/2);      			}		}		public static function drawRect(target:Sprite, x:Number = 0, y:Number = 0, w:Number = 100, h:Number = 100):void{			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.drawRect(x, y, w, h);		}		public static function fillRect(target:Sprite, x:Number = 0, y:Number = 0, w:Number = 100, h:Number = 100):void{			target.graphics.lineStyle(0, 0, 0);			target.graphics.beginFill(_color24, 1.0/255*_a);			target.graphics.drawRect(x, y, w, h);			target.graphics.endFill();		}		public static function drawRoundRect(target:Sprite, 									  x:Number = 0, y:Number = 0, 									  w:Number = 100, h:Number = 100, 									  ellipseWidth:Number = 1, ellipseHeight:Number = 1):void{			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);						target.graphics.drawRoundRect(x, y, w, h, ellipseWidth, ellipseHeight);		}		public static function fillRoundRect(target:Sprite, 									  x:Number = 0, y:Number = 0, 									  w:Number = 100, h:Number = 100, 									  ellipseWidth:Number = 1, ellipseHeight:Number = 1):void{			target.graphics.lineStyle(0, 0, 0);			target.graphics.beginFill(_color24, 1.0/255*_a);			target.graphics.drawRoundRect(x, y, w, h, ellipseWidth, ellipseHeight);			target.graphics.endFill();		}		public static function drawCircle(target:Sprite, 								   x:Number = 0, //center x								   y:Number = 0, //center y								   radius:Number = 0):void{			target.graphics.lineStyle(_lineWidth, _color24, 1.0 / 255 * _a);			target.graphics.drawCircle(x, y, radius);		}		public static function fillCircle(target:Sprite, 								   x:Number = 0, //center x								   y:Number = 0, //center y								   radius:Number = 0):void{			target.graphics.lineStyle(0, 0, 0);			target.graphics.beginFill(_color24, 1.0/255*_a);			target.graphics.drawCircle(x, y, radius);			target.graphics.endFill();				}	}	}